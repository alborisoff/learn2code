# -*- coding: utf-8 -*-

polygon = [[3, 2],
           [8, 7],
           [12, 8],
           [8, 12],
           [3, 10],
           [6, 7],
           [3, 2]]
point = [8, 10]


def bbox(poly):  # Получаем баунд-бокс обрезающего полигона
    xs, ys = [], []
    for poi in poly:
        xs.append(poi[0])
        ys.append(poi[1])
    return [min(xs), max(xs), min(ys), max(ys)]


# На входе - координаты отрезка, проходящего через определённую точку и координаты ребра полигона.
# На выходе - координаты точки пересечения.
# Проверять, пересекаются ли эти два отрезка, здесь не нужно, на входе подаются пересекающиеся отрезки.
def intersectwithnormal(normal, edge):
    # Здесь частный случай: ребро полигона пересекается с перпендикуляром к оси OX.
    xe1, ye1, xe2, ye2 = edge[0][0], edge[0][1], edge[1][0], edge[1][1]
    xn1, yn1, xn2, yn2 = normal[0][0], normal[0][1], normal[1][0], normal[1][1]
    xintersect = xn1  # Очевидно, что точка пересечения с перпендикуляром к оси OX будет иметь абсциссу перпендикуляра.
    # Остаётся только найти ординату точки пересечения.
    # Воспользуемся известным уравнением y = kx + b
    k = (ye2 - ye1) / (xe2 - xe1)
    b = ye1 - k*xe1
    yintersect = k*xintersect + b
    return [xintersect, yintersect]


# На входе - координаты точки и концов отрезка. Проверяем, лежит ли точка на отрезке.
def pointonsegment(point, segment):
    xp, yp = point[0], point[1]
    xs1, ys1, xs2, ys2 = segment[0][0], segment[0][1], segment[1][0], segment[1][1]
    if xp == xs1 == xs2:  # Если абсциссы отрезка и точки совпадают...
        return min(ys1, ys2) <= yp <= max(ys1, ys2)  # ..., то проверяем, находится ли ордината точки между концами
    # Предусмотрим ещё случай, когда точка совпадает с одним из концов отрезка
    elif (xp == xs1 and yp == xs2) or (xp == xs2 and xp == ys2):
        return True
    else:
        p = (xp - xs2) / (xs1 - xs2)
        if 0 <= p <= 1:
            return p == (yp - ys2) / (ys1 - ys2)




# На входе - координаты полигона (то есть, координаты углов; координаты первой и последней точек совпадают)
# и координаты отрезка, проходящего через проверяемую точку от верхнего до нижнего края баунд-бокса полигона.
# На выходе - массив с координатами точек пересечения полигона и отрезка.
def intersects(poly, poi):
    intersections = []
    normal = [[poi[0], bbox(poly)[2]], [poi[0], bbox(poly)[3]]]
    for i in range(len(poly) - 1):
        edge = [poly[i], poly[i + 1]]
        xe1, ye1, xe2, ye2 = edge[0][0], edge[0][1], edge[1][0], edge[1][1]
        xn1, yn1, xn2, yn2 = normal[0][0], normal[0][1], normal[1][0], normal[1][1]
        # По-моему, очевидная вещь: если есть отрезок, перпендикулярный оси абсцисс и идущий от края до края баунд-бокса
        # полигона (пусть он называется секущим), и если есть ребро полигона, одна из абсцисс которого
        # меньше или равна абсциссе секущего отрезка, а другая - больше или равна, то ребро полигона и секущий отрезок
        # пересекаются.
        if min(xe1, xe2) <= xn1 <= max(xe1, xe2):
            # Нужно ещё учесть частный случай, когда ребро полигона полностью лежит на контрольном отрезке.
            # В этом случае нужно засчитать одно пересечение - очевидно, это любой конец отрезка.
            if xe1 == xe2 == xn1:
                intersections.append([xe1, ye1])
            else:  # Функция пересечения секущего отрезка с ребром уже есть.
                intersections.append(intersectwithnormal(normal, edge))
    return intersections


print "Intersects:"
print intersects(polygon, point)
